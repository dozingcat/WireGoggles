package com.dozingcatsoftware.eyeball;

import com.dozingcatsoftware.util.AndroidUtils;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.Region;
import android.util.AttributeSet;
import android.view.View;

public class OverlayView extends View {
	
	CameraImageProcessor imageProcessor;
	Bitmap cornerImage;
	double cornerImageRatio;
	
	boolean fillScreen = false;
	boolean flipHorizontal = false;
	Matrix flipHorizontalMatrix = new Matrix();
	
	Rect dstRect = new Rect();
	Rect srcRect = new Rect();
	Rect cornerRect = new Rect();
	Rect pipRect = new Rect();
	
	int[] scaledWH = new int[2];

	public OverlayView(Context context, AttributeSet attrs) {
		super(context, attrs);
		// disable hardware acceleration so that clipRect(rect, Region.Op.DIFFERENCE) works
		AndroidUtils.setViewHardwareAcceleration(this, false);
	}
	
	double pictureInPictureRatio = 0;
	
	public boolean isOpaque() {
		return true;
	}
	
	Paint alphaPaint = null; //new Paint(); {alphaPaint.setAlpha(100);}
	Paint blackPaint = new Paint(); {blackPaint.setARGB(255, 0, 0, 0);}
	
	public void setFillScreen(boolean value) {
		fillScreen = value;
	}
	
	public void setFlipHorizontal(boolean value) {
	    flipHorizontal = value;
	}

	@Override
	protected void onDraw (Canvas canvas) {
		Bitmap previewBitmap = (imageProcessor!=null) ? imageProcessor.getBitmap() : null;		
		if (previewBitmap!=null) {
			int xmargin=0, ymargin=0;
			if (!fillScreen) {
				AndroidUtils.getScaledWidthAndHeightToMaximum(previewBitmap.getWidth(), previewBitmap.getHeight(), 
						this.getWidth(), this.getHeight(), scaledWH);
			    xmargin = (this.getWidth() - scaledWH[0]) / 2;
				ymargin = (this.getHeight() - scaledWH[1]) / 2;
			}
			// hopefully margins are even, otherwise could be off by one pixel
			boolean usePip = (pictureInPictureRatio>0 && pictureInPictureRatio<1);
			if (usePip) {
			    canvas.save();
			    pipRect.set(0, 0, (int)(this.getWidth() * pictureInPictureRatio), (int)(this.getHeight() * pictureInPictureRatio));
			    canvas.clipRect(pipRect, Region.Op.DIFFERENCE);
			}
			dstRect.set(xmargin, ymargin, this.getWidth()-xmargin, this.getHeight()-ymargin);
			if (flipHorizontal) {
			    canvas.save();
			    float scale = 1.0f*dstRect.width() / previewBitmap.getWidth();
			    flipHorizontalMatrix.reset();
			    flipHorizontalMatrix.setScale(-scale, scale);
			    flipHorizontalMatrix.postTranslate(dstRect.width()+xmargin, ymargin);
			    canvas.drawBitmap(previewBitmap, flipHorizontalMatrix, null);
			    canvas.restore();
			}
			else {
			    canvas.drawBitmap(previewBitmap, null, dstRect, alphaPaint);
			}
			// fill whatever area the bitmap doesn't cover with black
			if (xmargin>0) {
			    canvas.drawRect(0, 0, xmargin, this.getHeight(), blackPaint);
			    canvas.drawRect(this.getWidth()-xmargin, 0, this.getWidth(), this.getHeight(), blackPaint);
			}
			else if (ymargin>0) {
			    canvas.drawRect(0, 0, this.getWidth(), ymargin, blackPaint);
			    canvas.drawRect(0, this.getHeight()-ymargin, this.getWidth(), this.getHeight(), blackPaint);
			}
			if (usePip) {
			    canvas.restore();
			}
		}
		else {
			// fill with solid color to cover camera preview
			canvas.drawColor(0xFF000000);
		}
		// draw corner image in upper right if present
		drawCornerImage(canvas);
	}
	
	Paint cornerEdgePaint;
	
	void drawCornerImage(Canvas canvas) {
		if (cornerImage!=null && cornerImageRatio>0) {
			updateRectForCornerImage(cornerRect);

			// draw black and white borders to identify bounds
			if (cornerEdgePaint==null) {
				cornerEdgePaint = new Paint();
				cornerEdgePaint.setStyle(Paint.Style.STROKE);
			}
			cornerEdgePaint.setARGB(255,0,0,0);
			canvas.drawRect(cornerRect, cornerEdgePaint);

			cornerEdgePaint.setARGB(255,255,255,255);
			cornerRect.left += 1;
			cornerRect.bottom -= 1;
			canvas.drawRect(cornerRect, cornerEdgePaint);

			cornerRect.left += 1;
			cornerRect.bottom -= 1;
			canvas.drawBitmap(cornerImage, null, cornerRect, null);
		}
	}
	
	void updateRectForCornerImage(Rect rect) {
		int cx = (int)((1-cornerImageRatio)*this.getWidth());
		rect.set(cx, 0, this.getWidth(), (int)(cornerImageRatio*this.getHeight()));
	}
	
	public boolean isPointInCornerImage(float x, float y) {
		if (cornerImage==null || cornerImageRatio<=0) return false;
		updateRectForCornerImage(cornerRect);
		return cornerRect.contains((int)x, (int)y);
	}

	/////////////////////////////
	// autogenerated accessors //
	/////////////////////////////
	public double getPictureInPictureRatio() {
		return pictureInPictureRatio;
	}
	public void setPictureInPictureRatio(double value) {
		pictureInPictureRatio = value;
	}
	
	public CameraImageProcessor getImageProcessor() {
		return imageProcessor;
	}
	public void setImageProcessor(CameraImageProcessor imageProcessor) {
		this.imageProcessor = imageProcessor;
	}

	public Bitmap getCornerImage() {
		return cornerImage;
	}
	public void setCornerImage(Bitmap cornerImage) {
		this.cornerImage = cornerImage;
	}

	public double getCornerImageRatio() {
		return cornerImageRatio;
	}
	public void setCornerImageRatio(double cornerImageRatio) {
		this.cornerImageRatio = cornerImageRatio;
	}

}
